package io.qiot.covid19.edge.util.producers;

import java.security.KeyStore;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;

import io.vertx.core.net.JksOptions;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mutiny.core.Vertx;
import io.vertx.mutiny.mqtt.MqttClient;

/**
 * The Class MqttConnectionProducer.
 *
 * @author andreabattaglia
 */
@ApplicationScoped
public class MqttClientProducer {

    /** The logger. */
    @Inject
    Logger LOGGER;

    /** The host. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.host")
    String host;

    /** The port. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.port")
    short port;

    /** The enable ssl. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl")
    boolean enableSsl;

    /** The keystore location. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl.keystore.location")
    String keystoreLocation;

    /** The keystore password. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl.keystore.password")
    String keystorePassword;

    /** The truststore location. */
    @ConfigProperty(
            name = "qiot.mqtt.client.connection.ssl.truststore.location")
    String truststoreLocation;

    /** The truststore password. */
    @ConfigProperty(
            name = "qiot.mqtt.client.connection.ssl.truststore.password")
    String truststorePassword;

    /** The options. */
    MqttClientOptions options;

    /** The ssl context. */
    SSLContext sslContext;

    /** The trust manager factory. */
    TrustManagerFactory trustManagerFactory;

    /** The key store. */
    KeyStore keyStore;

    @Inject
    Vertx vertx;

    private MqttClient client;


    /**
     * Inits the.
     *
     * @throws Exception
     *             the exception
     */
    @PostConstruct
    void init() throws Exception {

        options = new MqttClientOptions();
        options.setReconnectAttempts(-1);
        options.setCleanSession(true);
        options.setAutoKeepAlive(true);
        options.setAutoGeneratedClientId(true);
        options.setSsl(enableSsl);
        options.setKeyCertOptions(getKeyCertOptions());
        options.setTrustOptions(getTrustOptions());
        options.setMaxInflightQueue(65535);
        
        LOGGER.debug("Vert.x Mqtt client options: {}", options);
        
        client = MqttClient.create(vertx, options);
    }

    private JksOptions getKeyCertOptions() {
        LOGGER.debug("getKeyCertOptions() - start");

        JksOptions returnJksOptions = new JksOptions().setPath(keystoreLocation).setPassword(keystorePassword);
        LOGGER.debug("getKeyCertOptions() - end - return value={}", returnJksOptions);
        return returnJksOptions;
    }

    private JksOptions getTrustOptions() {
        LOGGER.debug("getTrustOptions() - start");

        JksOptions returnJksOptions = new JksOptions().setPath(truststoreLocation).setPassword(truststorePassword);
        LOGGER.debug("getTrustOptions() - end - return value={}", returnJksOptions);
        return returnJksOptions;
    }

    /**
     * Produce mqtt connection.
     *
     * @return the mqtt client
     */
    @Produces
    public MqttClient produceMqttClient() {
        if (!client.isConnected()) {
            connectClient();

        }
        return client;
    }

    private void connectClient() {
        client.connectAndAwait(port, host, null);
        LOGGER.info("Client connected: {}", client.isConnected());
        // client.ping();
    }

    /**
     * Destroy.
     */
    @PreDestroy
    void destroy() {
        if (client != null && client.isConnected())
            client.disconnectAndForget();
    }

    // private static KeyCertOptions
    // getKeyCertOptions(MqttConnectorCommonConfiguration config) {
    //
    // if (config.getSsl() && config.getSslKeystoreLocation().isPresent()) {
    // String keyStoreLocation = config.getSslKeystoreLocation().get();
    // String sslKeystoreType = config.getSslKeystoreType();
    //
    // if (config.getSslKeystorePassword().isPresent()) {
    // String keyStorePassword = config.getSslKeystorePassword().get();
    // if ("jks".equalsIgnoreCase(sslKeystoreType)) {
    // return new JksOptions()
    // .setPath(keyStoreLocation)
    // .setPassword(keyStorePassword);
    // } else if ("pem".equalsIgnoreCase(sslKeystoreType)) {
    // return new PemKeyCertOptions()
    // .setCertPath(keyStoreLocation)
    // .setKeyPath(keyStorePassword);
    // }
    // // Default
    // return new PfxOptions()
    // .setPath(keyStoreLocation)
    // .setPassword(keyStorePassword);
    // } else {
    // new IllegalArgumentException("The attribute `ssl.keystore.password` on
    // connector 'smallrye-mqtt' (channel: "
    // + config.getChannel() + ") must be set for `ssl.keystore.type`" +
    // sslKeystoreType);
    // }
    // }
    // return null;
    // }

    /**
     * Gets the truststore value from the configuration. Attribute Name:
     * ssl.truststore Description: Set whether keystore type, location and
     * password. In case of pem type the location is the cert path. Default
     * Value: PfxOptions
     * 
     * @return the TrustOptions
     */

    // private static TrustOptions
    // getTrustOptions(MqttConnectorCommonConfiguration config) {
    //
    // if (config.getSsl() && config.getSslTruststoreLocation().isPresent()) {
    // String truststoreLocation = config.getSslTruststoreLocation().get();
    // String truststoreType = config.getSslTruststoreType();
    //
    // if ("pem".equalsIgnoreCase(truststoreType)) {
    // return new PemTrustOptions()
    // .addCertPath(truststoreLocation);
    // } else if (config.getSslTruststorePassword().isPresent()) {
    // String truststorePassword = config.getSslTruststorePassword().get();
    // if ("jks".equalsIgnoreCase(truststoreType)) {
    // return new JksOptions()
    // .setPath(truststoreLocation)
    // .setPassword(truststorePassword);
    // }
    // // Default
    // return new PfxOptions()
    // .setPath(truststoreLocation)
    // .setPassword(truststorePassword);
    // } else {
    // new IllegalArgumentException("The attribute `ssl.keystore.password` on
    // connector 'smallrye-mqtt' (channel: "
    // + config.getChannel() + ") must be set for `ssl.keystore.type`" +
    // truststoreType);
    // }
    // }
    // return null;
    // }

}
